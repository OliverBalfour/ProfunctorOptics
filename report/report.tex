\documentclass[]{report}

\usepackage{minted}
\setcounter{secnumdepth}{0}
\usepackage[margin=1in]{geometry}
\usepackage{caption}
\usepackage{parskip}
\usepackage{float}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage[hidelinks]{hyperref}
\usepackage{subcaption}
\usepackage{fancyhdr}
\usepackage[section]{placeins}
\usepackage[backend=bibtex, style=authoryear]{biblatex}
\addbibresource{./report.bib}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{longtable}
\usepackage{fontspec}
\setmonofont{Source Code Pro}

\title{Verified Profunctor Optics in Idris}
\author{Oliver Balfour}


\begin{document}
\maketitle

\begin{abstract}
Optics are a commonly used design pattern in industrial functional programming. They are convenient combinators for reading and updating fields in composite data structures. Common implementations such as Edward Kmett's Haskell \texttt{lens} library are highly complex. We discuss profunctor optics, a modern formulation of optics which is more flexible than the more common van Laarhoven formulation. This report discusses the implementation and formal verification of profunctor optics in Idris, a dependently typed functional programming language and theorem prover. TODO summarise results, discussion and conclusion
\end{abstract}

\tableofcontents
\newpage

\section{Introduction}

The view-update problem is the problem of how to neatly read and write small components of large composite data structures (\cite{foster2005combinators}). In imperative languages, objects are generally mutated in-place, circumventing the view-update problem altogether. Pure functional programming languages however are not afforded mutable variables, making the issue pernicious in industrial programs with highly complex data structures.

Optics are a pure functional solution to the view-update problem (\cite{foster2005combinators}). Data structures representing components in real world systems frequently have dozens of fields and nested data structures with additional complexity. In a pure functional language, updating a field in a composite data type such as \texttt{Maybe (a, Bool)} requires boilerplate functions for every such composite type as in the below Idris code:

\begin{minted}{idris}
updateComplexType : (a -> b) -> Maybe (a, Bool) -> Maybe (b, Bool)
updateComplexType f (Just (x, y)) = Just (f x, y)
updateComplexType f Nothing = Nothing
\end{minted}

As data structures become more complex, writing getters and setters becomes a tedious and bug-prone task. Optics are objects which represent a view into a data type which can be composed to create views into composite types, and used to view or update fields. Using the profunctor optics library discussed in this report, the above \texttt{updateComplexType} function may be defined as \texttt{updateComplexType = update (op . π₁)} where \texttt{op} is an optic for optional (\texttt{Maybe a}) types and \texttt{π₁} is a left projection optic for product types.

However, even in imperative languages there are often many benefits from using immutable objects. In JavaScript for example, there is an increasing trend towards pure functional state management for designing user interfaces, termed \textit{declarative UI} (\cite{declarativeUI}). Libraries such as Redux.js (\cite{reduxjs}) use an immutable state object with a group of actions that act on the state type whenever an event is triggered by user interactions. This presents numerous benefits such as simple control flow and undo/redo functionality. However, this requires a new state object after each event with perhaps a single field changed. The conventional approach in JavaScript is to use Immer.js (\cite{immerjs}), which rather than using pure optics exploits esoteric language features to emulate mutability on immutable objects. However, there is no fundamental reason why optics would not work equally well.

Profunctor optics are a very flexible and powerful encoding of optics, however they are highly complex, demonstrating a need for quality assurance.

In statically typed languages, types correspond with certain logical propositions and programs serve as proofs of those propositions (\cite{wadler2015propositions}). This insight is known as the Curry-Howard correspondence (\cite{sorensen2006curryhoward}) and it underpins theorem provers and formal verification. Dependent types are a feature of some type systems which allows types to depend on values. Dependent types allow programmers to encode first order logical propositions and equalities between expressions into the type system and prove many useful theorems and properties of their programs.

Idris is a dependently-typed functional programming language similar to Haskell which may be used as a theorem prover. This report discusses using Idris to both implement and formally verify a profunctor optics library. Dependent types are used to express and prove that the profunctor optics adhere to all relevant mathematical laws and desirable properties.

\newpage
\section{Background}

\subsection{Idris}

Idris is a Haskell-like functional programming language with first-class support for dependent types. It is an actively developed experimental research language. Syntactically Idris and Haskell are almost identical, the most notable difference is that \texttt{:} is used to declare types and \texttt{::} is the list \texttt{cons} constructor. Additionally, types are first class citizens so functions may accept or return types (values may depend on types), a strict generalisation of Haskell which only allows types to depend on types (type constructors).

Idris additionally has linear types based on quantitative type theory which allow types to be annotated with requirements that they must be used exactly 0 or 1 times at runtime (\cite{brady2021qtt}). Idris also has implicit (inferred) arguments. Unlike Haskell, Idris does not possess type inference, as type inference is undecidable in general for dependent types with non-empty typing contexts (\cite{dowek1993undecidability}). % https://cs.stackexchange.com/a/12957

Idris is unique in that it is a practical and simple functional programming language to understand given prerequisite Haskell experience, and it doubles up as a theorem prover. The type system is powerful enough to encode theorems about equalities between expressions and universal and existential quantifiers. This allows programmers to express and prove complex properties and invariants of their programs alongside their code, which makes languages like Idris a good candidate language for critical infrastructure and similar systems.

\subsection{Dependent Types}

Dependent types are types that depend on values. For example, the Idris type \texttt{Vect 3 Int} is inhabited by vectors of precisely 3 integers. We say the type is indexed by the value \texttt{3}.

Some other languages have equivalent types such as \texttt{std::array<int, 3>} in C++. However, in C++, non-type template parameters (that is, values the type depends on) must be statically evaluated because generic types are monomorphised at compile time (\cite{ISO:CPP}, 14.1.4). This means template arguments cannot be non-trivial expressions as in Idris.

There are two main kinds of dependent types. $\Pi$ types generalise the \texttt{Vect 3 Int} example above. The type $\Pi x.Px$, which is expressed as \texttt{(x:a) -> P x} in Idris for some \texttt{P : (x:a) -> Type} is a function type where the codomain type depends on the value of the argument \texttt{x}. This allows functions to dynamically compute their return types in a type-safe manner. For instance, the \texttt{replicate} function in the Idris standard library has the type \texttt{replicate : (len : Nat) -> a -> Vect len a}, using a $\Pi$ type to construct a length \texttt{len} vector of copies of an object.

The other kind is $\Sigma$ types, which in Idris are known as dependent pairs. The type $\Sigma x.Px$ corresponds with the dependent pair \texttt{(x:a ** P x)} which is a pair of a value and a type where the type may depend on the value. Dependent pairs are outside the scope of this report.

As types can depend on values, Idris has an equality type \texttt{=} indexed by two values. It has one constructor \texttt{Refl : x = x} (reflexivity). An instance of \texttt{Refl : a = b} in some cases is obtainable using type rewriting rules discussed later, in which case the expressions \texttt{a} and \texttt{b} share the same normal form and are intensionally equal.

Dependent types are useful because they allow programmers to express more sophisticated types such as length indexed vectors, which allow programmers to write total matrix multiplication functions. Additionally, logical propositions correspond with types, and dependent types are expressive enough to allow a language to be used as a theorem prover and formally verify properties of programs.

\subsection{Propositions as Types}

The Curry-Howard correspondence, also known as \textit{Propositions as Types}, is the observation that propositions in a logic correspond with types in a language and proofs correspond with function definitions (\cite{wadler2015propositions}). This observation underpins theorem provers like Idris, Coq and Lean. The theorem statement or goal is encoded in a type signature. The function body is a proof of the goal. If the program is well-typed, the proof is correct.

Every consistent type system encodes some set of logical propositions. Dependent types are expressive enough that they can encode an intuitionistic or constructive logic complete with implications, conjunction, disjunction, negation, quantifiers and equalities.

In Idris, the type \texttt{a} is interpreted as a proposition $a$, where $a$ is true iff \texttt{a} as a type is inhabited. A proof of $a$ is simply an object of type \texttt{a}. The function type \texttt{a -> b} is interpreted as a logical implication $a\implies b$. Intuitively, if a total function of type \texttt{a -> b} exists then the existence of an \texttt{a} guarantees the existence of a \texttt{b}. Logical negation is encoded as \texttt{a -> Void} where \texttt{Void} is uninhabited.

The equality type is especially useful in conjunction with. If $a=b$ and a constructive proof of this exists then \texttt{a = b} is a singleton type, and if no proof exists it is uninhabited and thus false.

A  is tabulated below.  $\Sigma$ types are encoded using a construct called dependent pairs, which is not discussed in this report. $\Pi$ types are encoded with function types where the return type depends on the argument.

\begin{longtable}[]{@{}lll@{}}
\toprule
Logic & Type Theory & Idris
Type \\
\midrule
\endhead
{\(T\)} & {\(\top\)} & \texttt{()} \\
{\(F\)} & {\(\bot\)} & \texttt{Void} \\
{\(a \land b\)} & {\(a \times b\)} & \texttt{(a,\ b)} \\
{\(a \vee b\)} & {\(a + b\)} & \texttt{Either\ a\ b} \\
{\(a\Rightarrow b\)} & {\(a \rightarrow b\)} &
\texttt{a\ -\textgreater{}\ b} \\
{\(\forall x.Px\)} & {\(\Pi x.Px\)} &
\texttt{(x:a)\ -\textgreater{}\ P\ x} \\
{\(\exists x.Px\)} & {\(\Sigma x.Px\)} & \texttt{(x:a\ **\ P\ x)} \\
{\(\neg p\)} & {\(p \rightarrow \bot\)} &
\texttt{p\ -\textgreater{}\ Void} \\
{$a=b$} & {$a=b$} & {\texttt{a = b}} \\
\bottomrule
\caption{Corresponding connectives and quantifiers. Note that the predicates in Idris are of the form \texttt{P\ :\ (x\ :\ a)\ -\textgreater{}\ Type} where \texttt{P\ x\ =\ ()} or \texttt{P\ x\ =\ Void}.}
\end{longtable}

\subsection{Proof Techniques}

Idris will reduce values in types to their normal form by applying function definitions. It will attempt to unify both sides of equality types as well by reducing either side until it coincides with the other. This allows proofs to skip many intermediate simplification steps. Idris will generally reduce values in types to their normal form, analogous to simplifying mathematical expressions. For instance \texttt{3 + 7 = 11} will be rewritten to \texttt{10 = 11} (which of course is uninhabited).

This allows us to write simple proofs as below, which are analogous to unit tests.

\begin{minted}{idris}
fact : Nat -> Nat
fact Z = 1
fact (S n) = (S n) * fact n

factTheorem : fact 5 = 120
factTheorem = Refl

factTheorem2 : (S n) * fact n = fact (S n)
factTheorem2 = Refl
\end{minted}

The main proof techniques in Idris are structural induction, rewriting types and ex falso quodlibet.

Structural induction is the most common tool. This entails case splitting a theorem over each constructor and recursively invoking the theorem on smaller components of an inductively defined structure. If Idris can determine the theorem is total as the recursive calls eventually reach the base case, the proof will type check. Recursive calls are analogous to inductive hypotheses.

For example,

\begin{minted}{idris}
-- ∀ n : Nat. n + 0 = n
natPlusZeroId : (n : Nat) -> n + 0 = n
natPlusZeroId Z = Refl
natPlusZeroId (S n) = cong S (natPlusZeroId n)

-- ∀ xs : List a. xs ++ [] = xs
listConcatRightNilId : (xs : List a) -> xs ++ [] = xs
listConcatRightNilId [] = Refl
listConcatRightNilId (x::xs) = cong (x::) (listConcatRightNilId xs)
\end{minted}

These proofs invoke a lemma in the Idris Prelude, \texttt{cong :\ (f:t->u) -> (a = b) -> (f a = f b)}, which is analogous to the rule $\forall f.~a=b\!\!\implies\!\! f(a)=f(b)$ in mathematics.

Idris also provides a facility for rewriting the goal type using an equality. For example:

\begin{minted}{idris}
trans' : a = b -> b = c -> a = c
trans' p1 p2 =
  -- goal: a = c
  rewrite p1 in  -- replace `a` with `b` in `a = c`
    -- new goal: b = c
    p2
\end{minted}

Rewriting can be convenient, however using a number of rewrites makes proofs difficult to follow. Prelude functions such as \texttt{trans}, \texttt{sym}, \texttt{cong} and \texttt{replace} can accomplish the same tasks with a more conventional proof structure.

As intuitionistic logics do not have the law of the excluded middle or double negation, proof by contradiction is not possible. Instead, ex falso quodlibet, the principle of explosion, must be used. In some cases a function has cases which are not possible but well-typed proofs must exist for those cases to satisfy the totality checker. In this case, rather than deriving a contradiction to show the state is not possible, the contradiction can be used with the function \texttt{void\ :\ Void\ ->\ a} to derive the proof goal.

Idris has holes like Haskell, which are placeholder expressions denoted \texttt{?hole\_name}. There is a \texttt{:t hole\_name} command in the Idris REPL which prints out the typing context and goal, much like other theorem provers like Coq. This is immensely useful in developing proofs.

\subsection{Limitations}

Dependently typed theorem provers are intuitionistic in nature, which is strictly less powerful than classical logic. There exist theorems which can be proven with classical logic for which no constructive proof in Idris exists.

Double negation cancellation is not true in general, as there is no canonical map \texttt{((a\ ->\ Void)\ ->\ Void)\ ->\ a}. Existence statements cannot be proven without finding a witness to the proof, so a proof by contradiction that $\neg\forall x.P(x)$ does not imply $\exists x.\neg P(x)$. Instead, a dependent pair containing an explicit $x$ satisfying $\neg P(x)$ must be constructed, which may not be possible.

Additionally, there is a distinction between intensional and extensional equality of functions. In mathematics, the statements $f=g$ and $\forall x. f(x)=g(x)$ are equivalent. In Idris however, only the forward implication is true. Function equality is intensional, meaning functions are equal iff the normal form of their lambda expressions are $\alpha$-equivalent, so they are the equal up to renaming bound variables. In many cases extensionally equal functions are not intensionally equal, so the Idris equality type may not be helpful. It is possible to use the built-in \texttt{believe\_me\ :\ a\ ->\ b} proof to introduce an extensionality axiom, however Idris cannot rewrite types if they invoke axioms as there essentially is no definition to substitute.

These limitations mean that many theorems of interest either cannot be proven or are much more difficult to prove in Idris. TODO examples

\subsection{Functors}

Before discussing profunctors, we discuss categories, functors, applicative functors and monads. A category is a mathematical object which consists of a collection of objects and between any two objects a collection of arrows or morphisms (\cite{mac1970categories}). We will only discuss locally small categories so we may assume these collections of morphisms are sets, called Hom-sets. The only properties categories must have is an associative composition operation on morphisms and an identity morphism on each object. Categories are a useful abstraction as they generalise objects and structure preserving maps between them from many different fields. There is a category of sets where objects are sets and Hom-sets contain functions, $\operatorname{Hom}(A,B)=\{ f : A\to B\text{ is a function} \}$. Morphism composition is function composition, and there exists an identity function on each set. In group theory, there is a category of groups where objects are groups and morphisms are group homomorphisms. Many other examples exist, for example partially ordered sets form categories where objects are elements and exactly one morphism exists between every ordered pair.

Notably, types and total functions in Idris form a category similar to the category of sets. For convenience, these categories are assumed the same.

Functors are structure preserving maps between categories (and thus morphisms in the category of categories). They consist of two components mapping objects and morphisms from the domain category to objects and morphisms in the codomain category. Functors respect identities $F(\text{id}_X)=\text{id}_{F(X)}$ and composition $F(f\circ g)=F(f)\circ F(g)$ An endofunctor is a functor which maps into the same category.

In Idris, generic containers such as lists and trees are endofunctors. The type constructor \texttt{List : Type -> Type} is the component of the functor mapping objects, and the \texttt{map : (a -> b) -> (List a -> List b)} function is the component mapping morphisms. Additionally, the partially applied arrow type \texttt{a->} is a functor, the covariant Hom functor (and partially applied Hom profunctor).

Monads are a subset of endofunctors equipped with two maps \texttt{η : a -> m a} and \texttt{μ : m (m a) -> m a} named pure/return and join respectively, where \texttt{m} is the monad. In functional programming, they can be used to encapsulate and compose side effecting functions in a type safe way (\cite{moggi1991notions}). The \texttt{IO} type constructor is a monad representing side effects which allows side effects to be composed and enforce that functions emitting side effects have a return type containing \texttt{IO}. Lists form a monad where \texttt{pure x = [x]} and \texttt{join = concat} and function composition results in a list of all possible applications of functions to arguments.

Monads satisfy the following laws:
\begin{enumerate}
	\item \texttt{∀ f,x. (return `join` f) x = f x} (left identity law, tildes denote infix function calls)
	\item \texttt{∀ f,x. (f `join` return) x = f x} (right identity law)
	\item \texttt{∀ f,g,h,x. f `join` (g `join` h) \$ x = (f `join` g) `join` h \$ x} (associativity)
\end{enumerate}

Monads naturally give rise to a category known as a Kleisli category (\cite{mac1970categories} p.147). In this category, the objects are the same as the category of types, and the morphisms are each of the form \texttt{a -> m b} so $\operatorname{Hom}(\texttt{a},\texttt{b})=\{ f : \texttt{a -> m b} \}$. Morphism composition utilises the join operation, so $f\circ_m g = \mu\circ \texttt{fmap}(f)\circ g$.

Applicative functors are a subset of endofunctors introduced by \cite{mcbride2008applicative} as a useful abstraction in functional programming intermediate between endofunctors and monads. They are endofunctors equipped with maps \texttt{pure : a -> f a} and \texttt{ap : f (a -> b) -> (f a -> f b)} (written \texttt{<*>} as an infix operator) for every applicative \texttt{f} satisfying the following properties

\begin{enumerate}
	\item \texttt{∀ v. pure id <*> v = v} (identity law)
	\item \texttt{∀ g,x. pure g <*> pure x = pure (g x)} (homomorphism law)
	\item \texttt{∀ u,y. u <*> pure y = pure (\textbackslash{}x => x y) <*> y} (interchange law)
	\item \texttt{∀ u,v,w. ((pure (.) <*> u) <*> v) <*> w = u <*> (v <*> w)} (composition law)
\end{enumerate}

\subsection{Profunctors}

Profunctors are a generalisation of functors which relate to Hom-sets. A profunctor from category $C$ to $D$ formally is a functor $D^{op}\times C\to\mathbf{Set}$, where $D^{op}$ is the dual category of $D$ and $\times$ is similar to the Cartesian product (\cite{nlab:profunctor}). The dual category has the same objects as $D$, but the directions of all morphisms are reversed.

As we assume the categories of types and sets are identical, a profunctor in Idris is a type constructor \texttt{p} which takes two type variables equipped with a map \texttt{dimap : (a -> b) -> (c -> d) -> p b c -> p a d}. Then every profunctor $p$ gives rise to a (covariant) functor $p(a,-)$ for all $a$, and a contravariant functor (functor mapping from the dual category) $p(-,a)$.

In Idris, profunctors usually correspond to arrow-like types. For instance, \texttt{->} is a profunctor. The Hom function is a profunctor, and the Hom functor is simply the partially applied Hom profunctor. Additionally, for any monad \texttt{m} the Hom profunctor in its Kleisli category is a profunctor in the category of types. Hash maps or dictionaries form profunctors (\cite{milewskicoends}).

As we will see, profunctor optics are generic over profunctors, and different profunctors make optics behave differently. The Hom profunctor allows for updating fields in composite types, the Kleisli Hom profunctor does the same but while accumulating side effects, the Const profunctor recovers sum type constructors and the Forget profunctor turns optics into getters.

Cartesian profunctors are profunctors equipped with a map \texttt{first : p a b -> p (a,c) (b,c)} and Cocartesian profunctors have a map \texttt{left : p a b -> p (Either a c) (Either b c)}. Restricting to Cartesian profunctors will restrict to lenses and to Cocartesian profunctors will restrict to prisms.

\subsection{Optics}

Optics are data accessors that ease reading and writing into composite data structures. Industrial programs tend to have very complex and deeply nested data structures, which makes tasks like copying and updating a single field in a deeply nested data structure in a functional style very cumbersome. Optics are an elegant solution to this problem. They are objects which represent a view into a field of a data structure which can be composed for nested structures and used to view and update the field they model.

There are many encodings of optics. This report discusses simple algebraic data type optics, van Laarhoven optics (\cite{laarhoven2011lens}) and profunctor optics (\cite{pickering2017profunctor}). Most established implementations such as the \texttt{lens} library in Haskell (\cite{ekmettlens}) use the van Laarhoven design, however these have many limitations. One of the principal benefits of optics is that they compose elegantly, however the van Laarhoven encoding makes a distinction between lenses (optics for product types) and prisms (optics for sum types) and does not allow composition of lenses and optics, so you cannot express an optic for the integer in a \texttt{Maybe (Integer, String)} type (\cite{pickering2017profunctor}).

However, profunctor optics generalise optics to work around these issues. As with many other functional programming design patterns, they are inspired by category theory, specifically the notion of a profunctor. Profunctor optics are generic over the typeclass of profunctors, so they allow choice of profunctor in which to use an optic. This allows programmers to not just use optics to view and update, but to also accumulate side effects and recover constructors for sum types in the process.

A major concern is that optics are very complicated. Formal verification of profunctor optics is thus a natural application of dependent types.

The simplest encoding of optics is to create typeclasses (interfaces in Idris) for lenses, prisms, traversals and adapters. Lenses are optics for product types that allow viewing and updating fields. Prisms are optics for sum types that allow pattern matching if a field is present and constructing a sum type from one of the components. Adapters and traversals are optics for isomorphic types and container types respectively and are not discussed in this report.

In the below encoding, \texttt{PrimitiveLens a b (a,c) (b,c)} means a view into the \texttt{a} in \texttt{(a,c)}. The other two type variables add a degree of freedom when updating tuples to change the type of the left element of the tuple.

\begin{minted}{idris}
record PrimitiveLens a b s t where
  constructor MkPrimLens
  view : s -> a
  update : (b, s) -> t

record PrimitivePrism a b s t where
  constructor MkPrimLens
  match : s -> Either t a
  build : b -> t

-- Left projection lens
_1 : PrimitiveLens a b (a,c) (b,c)
_1 = MkPrimLens fst update where
  update : (b, (a, c)) -> (b, c)
  update (x', (x, y)) = (x', y)
\end{minted}

Then \texttt{view \_1 (2, True) == 2}. However, there is no clear way to compose two lenses or two prisms using this encoding, and it is not possible to compose a lens and a prism using these two typeclasses.

A more powerful encoding is van Laarhoven functor transformer lenses (\cite{laarhoven2011lens}). These are parameterised over the functor typeclass, where different functors applied to the optics change how they behave. In Haskell,

\begin{minted}{haskell}
type LaarhovenLens a b = forall f. Functor f => (b -> f b) -> (a -> f a)
\end{minted}

Under this encoding, the above product projection lens would have type \texttt{LaarhovenLens (a,b) a}. It can be modified to have the additional degree of freedom in the simpler encoding.

The \texttt{Const a} functor \texttt{newtype Const a b = \{ unConst :: a \}} stores a value of type \texttt{a}. Applied to the above definition, it produces a getter \texttt{view optic structure = unConst \$ optic (\textbackslash{}x -> Const x) structure}. Likewise, the identity functor \texttt{newtype Id a = \{ unId :: a \}} produces an update function \texttt{update optic field structure = unId \$ optic (\textbackslash{}x -> Id field) structure}.

These optics are simple functions and so support composition, however lenses and prisms are still mutually exclusive and cannot be composed. This leaves profunctor optics, which generalise van Laarhoven's functor transformer lenses and are flexible enough to support composition.

\subsection{Profunctor Optics}

Profunctor optics are

\begin{minted}{idris}
Optic p a b s t = p a b -> p s t
\end{minted}

what are profunctor optics?
why are they good?
what are common/useful optics with examples?
optics on type indexed data types???
correspondence with van Laarhoven \cite{boisseau2018yoneda} - this means even though they're harder to write you can map primitive ones to complex ones

\section{Formally Verified Profunctor Optics}

> We can then have a penultimate section discussing a framework for formal verification of profunctor optics in Idris and discussing the structure and details of your solution (minimal use of source code here). Concretely, this section should properly motivate the formal verification of profunctor optics and then progress through your solution. Talk concepts and give formal examples but avoid using source code (you can refer to sections in the appendix where necessary though).


VProfunctor = verified not v-enriched


\section{Related Work}

Existing research on profunctor optics

Much existing work is focused on the correspondence between the van Larrhoven and profunctor representations of lenses, prisms, adapters and traversals. \cite{boisseau2018yoneda} provides a proof of the correspondence with the Yoneda lemma, and previous work including \cite{pickering2017profunctor} and \cite{milewski2017profunctor} provide proofs invoking more complex machinery such as Tambara modules and tensor products.

No prior work is known to have been done on formally verified profunctor optics.

Future research on profunctor optics for dependent types such as type indexed syntax trees could be very useful. This would enable programming languages written in Idris to use dependent types to verify all syntax trees are well typed and use optics to elegantly traverse, view and update subtrees.

\section{Conclusion}

> Finally in the conclusion you can discuss what you've accomplished, what improvements could be made, and other related work in the field (i.e where the current boundaries of formally verified profunctor optics are if any - and general boundaries of profunctor optics research).


\printbibliography

\newpage
\section{Appendix: Source Code}

Mirrored at \href{https://github.com/OliverBalfour/ProfunctorOptics}{https://github.com/OliverBalfour/ProfunctorOptics}

\subsection{Simple Optics: PrimitiveOptics.idr}

\inputminted[breaklines,linenos]{idris}{../src/Primitive/PrimitiveOptics.idr}

\subsection{Morphisms: Morphism.idr}

\inputminted[breaklines,linenos]{idris}{../src/Category/Morphism.idr}

\subsection{Verified Functors and Applicatives: VFunctor.idr}

\inputminted[breaklines,linenos]{idris}{../src/Category/VFunctor.idr}

\subsection{Verified Profunctors: VProfunctor.idr}

\inputminted[breaklines,linenos]{idris}{../src/Category/VProfunctor.idr}

\subsection{Profunctor Optics: Main.idr}

\inputminted[breaklines,linenos]{idris}{../src/Main.idr}

\end{document}          






